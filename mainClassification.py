import tensorflow as tf
import keras

from dataLoader import DataLoder
from buildModel import ModelBuilder, N, STEPS, LOSS, BATCH_SIZE, NUMOFCLASS
from modifiedOptimizer import optimizer as op

import matplotlib.pyplot as plt
import csv
import time
import random
import numpy as np

def drawPlot(arr, saveDir, label='{}', xlabel='epoch', ylabel='loss', isAcc=False):
    for i, a in enumerate(arr):
        plt.plot(range(STEPS + 1), a, label=label.format(i))
    
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    if isAcc: plt.ylim(0,1)
    plt.legend(loc='upper left')
    plt.savefig(saveDir)
    plt.clf()

if __name__ == "__main__":
    # Section I: Build the data set
    # Load Malware Data Set
    malwareData = DataLoder()
    x_train, x_test, y_train, y_test = malwareData.load_data(
                                        train_path='./data_3000/', 
                                        test_path='./classification_image_test/', 
                                        label_path='./classification_labels.csv')
    psoFunc = op()
    vanillaFunc = op()

    # Section II: First run the backpropagation simulation
    vanillaStart = time.time()
    vanillaModel = ModelBuilder()
    print("build vanilla model success")
    

    model_s, vanillaLossList = vanillaFunc.vanilla_backpropagation(vanillaModel, x_train, y_train)
    vanillaEnd = time.time()
    
    b_train_score = model_s.evaluate(x_train, y_train, batch_size=BATCH_SIZE, verbose=1)
    b_test_score = model_s.evaluate(x_test, y_test, batch_size=BATCH_SIZE, verbose=1)
    print("VanillaBackprop Loss train: {:.4f}  test: {:.4f}".format(b_train_score[0], b_test_score[0]))
    print("VanillaBackprop Accuracy train: {:.4f}  test: {:.4f}".format(b_train_score[1], b_test_score[1]))
    
    
    
    #Section III: Use PSO algorithm
    psoStart = time.time()
    MYpsoModel = ModelBuilder().build_model(LOSS)
    print("build pso model success")

    psoBestModel = psoFunc.pso(MYpsoModel, x_train, y_train)
    psoEnd = time.time()

    eval_test = psoBestModel.evaluate(x_test, y_test, batch_size=BATCH_SIZE, verbose=1)
    print("loss: {}, acc: {}".format(eval_test[0], eval_test[1]))

    
    

    print("=========== Elapsed Time (Latency) ==============")
    print("MobileNets : \t {:.4f} ".format(vanillaEnd - vanillaStart))
    print("-------------------------------------------------")
    print("PSO : \t {:.4f} ".format(psoEnd - psoStart))
    print("-------------------------------------------------")
